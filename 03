                                                                                          //Chapter03

  /*В языке jаvа определены восемь примитивнъtх типов данных: byte, short, int,long, char, float, douЫe и boolean. Примитивные типы называют также про-
стыми, и в данной книге употребляются оба эти термина. Примитивные типы можно разделить на следующие четыре группы.
  - Целые числа. Эта группа включает в себя типы данных byte, short, int
и long, представляющие целые числа со знаком.
  - Числа с плавающей точкой(действителъные числа). Эта группа включает в себя типы данных float и douЫe, представляющие числа с точностью до определенного знака после десятичной точки.
  - Символы. Эта группа включает в себя тип данных char, представляющий
символы, например буквы и цифры, из определенного набора.
  - Логические значения. Эта группа включает в себя тип данных boolean, специально предназначенный для представления логических истинных и ложных значений. */

  //В charJava используется кодировка в Юникод (Unicode) , определяющем полный набор международных символов на всех известных языках мира. Юникод унифицирует десятки наборов символов, в том числе латинский,греческий, арабский алфавит, 
кириллицу, иврит, японские и тайские иероглифы и многие другие символы. Для хранения этих символов требуется 16 бит, и поэтому в java тип char является 16-разрядным. Отрицательных значений типа char не существует.



            //пример с long
class Light {
    public static void main(String[] args) {
        int lightspeed;
        long days;
        long seconds;
        long distance;
        // приблизительная скорость света , миль в секунду
        lightspeed = 186000;
        days = 1000;            // указать количества дней
        seconds = days * 24 * 60 * 60;             // преобразовать в секунды
        distance = lightspeed * seconds;           // вычислить расстояние
        System.out.print(" Зa " + days);
        System.out.print(" дней свет пройдет около ");
        System.out.println(distance + " миль.");
    }
}
        /* Выводит следующий результат:
        За 1000 дней свет пройдет около 1607040 0000000 миль . */


          //пример с double
class Area {
    public static void main(String[] args) {
        double pi, r, a;
        r = 10.8;       //радиус окружности
        pi = 3.1416;       //числа=о пи
        a = pi * r * r;      // вычислить площадь круг
                System.out.println("Плoщaдь круга равна 11 "+ a);
    }
}
//Вывод: Плoщaдь круга равна 11 366.4362


        //пример c char
class CharDemo {
    public static void main(String[] args) {
        char chl, ch2;
        chl = 88; // код символа Х
        ch2 = 'У';
        System.out.print("chl и ch2 : 11 ");
        System.out.print(chl + " " + ch2);
    }
}
        //Вывод:      chl и ch2 : Х У


        //пример c char. Символьные переменные ведут себя как целочисленные значения
class CharDemo2 {
    public static void main(String[] args) {
        char chl;
        chl = 'Х';
        System.out.println(" ch l содержит " + chl);
        chl++;                          // увеличить на единицу значение переменной chl
        System.out.println(" ch l теперь содержит " + chl);
            }
}
        //Вывод:      chl содержит Х
        //            chl теперь содержит У


         //пример c char
class BoolTest {
    public static void main(String[] args) {
        boolean b;
        b = false;
        System.out.println("b равно " + b);
        b = true;
        System.out.println("b равно " + b);
                    //значение типа boolean может управлять оператором if
        if (b)
            System.out.println(" Этoт код выполняется.");
        b = false;
        if (b)
            System.out.println(" Этoт код не выполняется.");
        System.out.println(" lO > 9 равно " + (10 > 9) );         // результат сравнения - значение типа boolean
    }
}
        /* Вывод:   b равно false
                    b равно true
                    Этoт код выполняется.
                    lO > 9 равно true   */


          //пример c Динамической инициализацией
class Dyninit {
    public static void main(String[] args) {
        double a = 3.0 , b = 4.0;
        double c = Math.sqrt (a * a + b * b );
        System.out.println("Гипoтeнyзa равна "+ c ) ;    // динамическая инициализация переменной с
    }
}
        // Вывод:  Гипoтeнyзa равна 5.0  


        //Пример области действия блока кода
class Scope {
    public static void main(String[] args) {
        int x ; // эта переменная доступна всему коду из метода lll&in ()
        x = 10;
        if (x == 10) {          // начало новой области действия ,
            int y = 20;             // доступной только этому блоку кода

                                    // обе переменные х и у доступны в э той области действия
            System.out.println(" x и у: " + x + " " + y);
            x = y * 2;
        }
                // y = 100; // ОШИБКА ! переменная у недоступна
                // в этой области действия , тогда как
                //  переменная х доступна и эдесь
        y = 100;          // ОШИБКА ! переменная у недоступна
                         // в этой области действия , тогда как
                         //  переменная х доступна и эдесь
                System.out.println ( " x равно " + x ) ;
    }
}
  

              //Пример со сроком действия переменной
class LifeTime {
    public static void main(String[] args) {
        int x;
        for (x = 0; x < 3; x++ ) {
            int y = -1;         // переменная у инициализируется прикаждом вхождении в блок кода
            System.out.println ( " y равно : "+ y );      // здесь всегда выводится значение -1

            y = 100;
            System.out.println ( " y теперь равно : " + y );
    }
}
}
        /* Вывод:   y равно : -1
                    y теперь равно : 100
                    y равно : -1
                    y теперь равно : 100
                    y равно : -1
                    y теперь равно : 100   */


               //Пример с ошибкой компиляции со сроком действия переменной
class LifeTime {
    public static void main(String[] args) {
        int bar = 1;
        {                    //создается новая область действия
            int bar = 2;    // Ошибка компиляци
        }                   //переменная bar уже определена
    }
}




                                                                          //Приведение несовместимых типов
/*Приведение - это всего лишь явное преобразование типов. Общая форма приведения типов имеет следующий вид: (целевой_тип) значение, где параметр целевой_ тип обозначает тип, в который нужно преобразовать указанное значение.
Если значение целочисленного типа больше допустимого диапазона
значений типа byte , оно будет сведено к результату деления по модулю (остатку
от целочисленного деления) на диапазон типа byte.
int а;
byte Ь;
//..
Ь = ( byte ) а;    
При присваивании значения с плавающей точкой переменной целочисленно-
го типа выполняется другой вид преобразования типов - усечение.   */


       //Пример приведение типов
class LifeTime {
    public static void main(String[] args) {
        byte b;
        int i = 257;
        double d = 323.142;
            System.out.println( " \nПpeoбpaзoвaниe типа int в тип byte." ) ;
        b = (byte) i;
            System.out.println(" i и b " + i + " " + b ) ;
            System.out . println ( " \nПpeoбpaзoвaниe типа douЫe в тип int.") ;
        i = (int) d;
            System.out . println ( "d и i " + d +" " + i ) ;
            System.out . println ( " \nПpeoбpaзoвaниe типа douЫe в тип byte." ) ;
        b = (byte) d;
            System.out . println ( "d и Ь " + d +" "+ b ) ;
}
}
        /* Вывод:   Пpeoбpaзoвaниe типа int в тип byte.
                    i и b 257 1
 
                    Пpeoбpaзoвaниe типа douЫe в тип int.
                       d и i 323.142 323
 
                    Пpeoбpaзoвaниe типа douЫe в тип byte.
                    d и Ь 323.142 67  */


        //Пример продвижение типа одного из операндов для соответствия типу второго операнда
class LifeTime {
    public static void main(String[] args) {
        byte b = 42;
        char c= 'а' ;
        short s = 1024;
        int i = 50000;
        float f = 5.67f;
        double d = .1234 ;
        double result = (f * b) + (i / c) - (d * s ) ;
        /*В промежуточном выражении f * b тип переменной и продвигается к типу float, а результат вычисления этого выражения также относится к типу
         float. В следующем промежуточном выражении i /с тип переменной с продвигается к типу int, а результат вычисления этого выражения относится к типу int.
        Затем в промежуточном выражении d * s тип переменной s продвигается к типу double, а результат его вычисления относится к типу double. Далее выполняются
        операции с этими тремя промежуточными резулитирующими значениями типа float, int и double. Результат сложения значений типа float и int. относится к типу
        float.Затем тип разности суммарного  значения типа float и последнего значения тина double продвигается к тину double, который и становится
        окончательным типом реаультата вычисления выражения в целом. */
        System.out.println ( ( f * b) + "+" + (i / c) + " - " + (d * s ) );
        System.out.println ( " result = " + result );
    }



























